# Session State Management Rules

You are an AI assistant with persistent context across sessions via PROJECT_STATE.md and PROJECT_CONTEXT.md.

## File Overview

| File | Purpose | Update Frequency |
|------|---------|------------------|
| `PROJECT_STATE.md` | Current session state (hot) | Every session |
| `PROJECT_CONTEXT.md` | Project knowledge (cold) | When content changes |
| `PROJECT_ARCHIVE.md` | Historical entries | During archival |

## Context Loading Protocol

**At the START of every conversation:**

1. Read `PROJECT_STATE.md` FIRST before doing anything else
2. Check `Active Session` field—if another session is active on same branch, ask user before proceeding
3. Set `Active Session` to your tool/context identifier (e.g., "Cursor on main", "Claude Code on feature/auth")
4. Read `Session Handoff` section and acknowledge any mid-flight work
5. Clear the `Session Handoff` section after incorporating context
6. If starting a new feature or returning from break, also read `PROJECT_CONTEXT.md`
7. Briefly acknowledge where we are: "Continuing with [current task]..." (one line, not verbose)

**If PROJECT_STATE.md is missing or contains only placeholders:**
- Inform user: "I see this is a fresh project state. Let me help you populate it."
- Ask for essentials: project name, current phase, tech stack, current focus
- Populate Meta and Active Context from responses
- Do NOT scan entire codebase to auto-populate

## State Update Protocol

**At the END of every completed task, you MUST update PROJECT_STATE.md:**

1. Update `## Meta` with current timestamp and task description
2. Move completed items from `## Current Task Breakdown` (mark with [x])
3. Add entry to `## Recent Changes` (prepend, keep last 10 max)
4. Update `## Next Steps` based on what you learned
5. Update `Current Branch` if you switched branches

**Update BEFORE telling the user you're done.** This is mandatory, not optional.

**Update PROJECT_CONTEXT.md when:**
- You discover a gotcha → add to Lessons Learned
- You make a significant decision → add to Decisions Log
- You take a shortcut under time pressure → add to Technical Debt
- You identify a recurring issue → add to Failure Patterns
- You create a stable checkpoint → add to Stable Checkpoints

## Session Handoff Protocol

**Before ending ANY session:**

1. Check if work is incomplete or in-progress
2. If yes, populate `## Session Handoff` with:
   - What you were doing
   - What files are in a modified state
   - Any context that would be lost
   - If branch has open PR, note PR number
3. Clear `Active Session` (set to "None")

**At start of next session:**
1. Read Session Handoff section
2. Acknowledge any mid-flight work: "Resuming: [description]"
3. Clear the section after incorporating context

## Multi-Agent Safety Protocol

**At session START:**
1. Check `Active Session` field in Meta
2. If another session is active:
   - If same branch: ASK user "Another session may be active. Continue anyway?"
   - If different branch: Proceed (separate workstreams)
3. Set `Active Session` to your tool/context identifier

**At session END:**
1. Clear `Active Session` (set to "None")
2. This happens BEFORE populating Session Handoff

**If you detect conflicts:**
1. Do NOT overwrite—ask user which version to keep
2. State files use last-write-wins; be conservative

**Identifier format:** `[Tool] on [branch]`
- Examples: "Cursor on feature/auth", "Claude Code on main", "HumanLayer on fix/bug-123"

## Atomic Update Protocol

When updating state files:
1. Read current content
2. Make ALL changes in memory
3. Write complete file in single operation
4. Verify write succeeded before proceeding

Never:
- Make multiple sequential small edits
- Leave file in intermediate state
- Write partial sections

## What to Track

### Always Update (PROJECT_STATE.md)
- Current task progress and completion
- New files created or significantly modified
- Blockers encountered and resolved
- Branch changes

### Update When Relevant (PROJECT_CONTEXT.md)
- Gotchas and workarounds discovered → Lessons Learned
- Decisions made during implementation → Decisions Log
- Shortcuts taken → Technical Debt
- Recurring issues identified → Failure Patterns
- File relationships identified → File Relationships
- External API quirks or constraints → External Dependencies

### Never Track
- Routine file reads
- Minor formatting changes
- Conversation details (just outcomes)

## Token Efficiency Rules

1. **State file is your shortcut** - If PROJECT_STATE.md describes the current context, use it instead of scanning files
2. **Reference, don't duplicate** - Point to files/functions, don't copy their contents into state
3. **Concise entries** - Each log entry should be one line when possible
4. **Prune aggressively** - Keep Recent Changes to last 10 items, archive older entries

## Task Breakdown Management

For complex features (more than ~30 mins of work):

1. Create a checkbox breakdown in `## Current Task Breakdown`
2. Update checkboxes as you complete subtasks
3. Add sub-items for discovered complexity
4. When feature complete, move summary to `## Recent Changes` and clear breakdown

Example:
```markdown
## Current Task Breakdown
Feature: User Authentication
- [x] Set up auth client
- [x] Create login form
- [ ] Password reset flow
  - [x] Request UI
  - [ ] Email template ← CURRENT
  - [ ] Confirmation page
```

## Lessons Learned Protocol

When you discover something non-obvious:

1. **Immediately** add to `## Lessons Learned` in PROJECT_CONTEXT.md
2. Format: `- [DATE] Brief description of gotcha/solution`
3. Before troubleshooting any issue, CHECK this section first—solution may exist

Examples of what to log:
- API quirks: "Supabase RLS must be configured before seeding data"
- Framework gotchas: "Next.js 14 server actions can't be called from client directly"
- Tooling issues: "Prisma requires regeneration after schema changes"

## Decision Logging

For significant decisions (architecture, library choices, patterns):

1. Log in `## Decisions Log` in PROJECT_CONTEXT.md with date
2. Include brief rationale (WHY, not just WHAT)
3. Note alternatives considered if relevant

This prevents re-debating settled decisions in future sessions.

## State Validation Triggers

**Validate state file accuracy when:**
1. Starting work on a NEW feature (not continuation)
2. Switching branches
3. After any file deletion or major rename
4. After 15+ tool calls without a state update
5. When something feels "off" or context seems stale
6. After returning from extended break (>24 hours)

**Validation checklist:**
- [ ] Does `Current Branch` match actual branch?
- [ ] Does `Current Task Breakdown` reflect actual progress?
- [ ] Are `Next Steps` still the right priorities?
- [ ] Is `Active Session` correctly set?

**If discrepancies found:**
1. Update state BEFORE continuing work
2. Note significant corrections in Session Handoff

## Stable Checkpoints

Before making significant/risky changes:

1. Note current git commit in `## Stable Checkpoints` in PROJECT_CONTEXT.md
2. Add description of what's working
3. Add recovery notes (what command to run, what breaks if you go further)
4. Reference this if rollback needed

## File Relationships

When you notice files that change together:

1. Add to `## File Relationships` in PROJECT_CONTEXT.md
2. Format: `**Component X:** file1.ts ↔ file2.ts ↔ file3.ts`
3. Check this section when modifying related files to avoid breaking changes

## Archival Protocol

**When to archive:**
- PROJECT_STATE.md exceeds 100 lines
- Monthly (first session of new month)
- When completing a major feature/milestone

**What to archive:**
- Recent Changes older than 2 weeks (keep last 10)
- Completed Task Breakdowns (move summary to archive)
- Resolved blockers

**How to archive:**
1. Create/update PROJECT_ARCHIVE.md
2. Move old entries under month header
3. Keep PROJECT_STATE.md focused on current work

**What stays in PROJECT_CONTEXT.md (never archived):**
- Technical Debt (until resolved)
- Failure Patterns (until obsolete)
- Lessons Learned (cumulative knowledge)
- Decisions Log (permanent record)

## Incremental Population

When you notice a section is empty or sparse during normal work:

**Do:**
- Populate it naturally as relevant information emerges
- Example: After making a decision, add to Decisions Log
- Example: After discovering a gotcha, add to Lessons Learned

**Don't:**
- Stop work to exhaustively fill empty sections
- Ask user to populate sections unrelated to current task
- Auto-generate content by scanning codebase

**Gentle prompts (use sparingly, max 1 per session):**
- "I noticed [section] is empty. Want me to add [specific item] based on what we just did?"
- Only prompt if the addition is directly relevant to completed work

## Error Recovery

**If you lose context mid-session:**
- Re-read PROJECT_STATE.md
- Ask user to confirm current task

**If state file seems outdated:**
- Ask user: "PROJECT_STATE.md shows [X] as current. Is this still accurate?"
- Update based on their response

**If conflicting information:**
- User's direct instructions override state file
- Update state file to reflect new direction

## Response Behavior

- **Don't narrate state management** - Update silently, don't say "I'm now updating the state file..."
- **Do confirm context briefly** - "Continuing with password reset flow..." (one line)
- **Don't over-explain** - State file is for YOUR reference, not a report to the user
- **Do surface blockers** - If state file shows unresolved blockers, mention them
